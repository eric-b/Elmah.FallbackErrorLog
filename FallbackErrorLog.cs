using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Elmah
{
    /// <summary>
    /// Composite ErrorLog implementation.
    /// </summary>
    public class FallbackErrorLog : ErrorLog
    {
        private readonly Dictionary<string, ErrorLog> _errorLogs;



        /// <summary>
        /// <para>Single constructor from configuration settings.</para>
        /// </summary>
        /// <param name="config">The keys are of type string and values ​​of type IDictionary.
        /// The key is a unique name (used for traces) and value to the configuration attributes, including the attribute "type".
        /// This parameter is generated by <see cref="FallbackErrorLogSectionHandler"/>.</param>
        public FallbackErrorLog(IDictionary config)
        {
            if (config == null)
                throw new ArgumentNullException("config");

            _errorLogs = new Dictionary<string, ErrorLog>(config.Count);

            foreach (KeyValuePair<string, IDictionary> kvp in config)
            {
                var typeSpec = kvp.Value["type"] as string;
                if (typeSpec != null)
                {
                    Type type = Type.GetType(typeSpec, true);
                    var cfgCopy = (IDictionary)((ICloneable)kvp.Value).Clone();
                    cfgCopy.Remove("type");
                    _errorLogs.Add(kvp.Key, (ErrorLog)Activator.CreateInstance(type, new object[] { cfgCopy }));
                }
            }

            if (_errorLogs.Count == 0)
                _errorLogs.Add("default", new MemoryErrorLog());
        }

        public override ErrorLogEntry GetError(string id)
        {
            if (string.IsNullOrEmpty(id))
                throw new ArgumentNullException("id");
            foreach (var log in _errorLogs.Values)
            {
                try
                {
                    var error = log.GetError(id);
                    if (error != null)
                        return error;
                }
                catch { }
            }
            return null;
        }

        public override int GetErrors(int pageIndex, int pageSize, System.Collections.IList errorEntryList)
        {
            if (errorEntryList == null)
                throw new ArgumentNullException("errorEntryList");
            if (pageIndex < 0)
                throw new ArgumentOutOfRangeException("pageIndex", pageIndex, null);
            if (pageSize < 0)
                throw new ArgumentOutOfRangeException("pageSize", pageSize, null);
            if (errorEntryList.Count != 0)
                throw new InvalidOperationException("errorEntryList must be empty.");

            var initialCapacity = pageSize * _errorLogs.Count;
            List<ErrorLogEntry> list = new List<ErrorLogEntry>(initialCapacity);
            foreach (var log in _errorLogs.Values)
            {
                try
                {
                    List<ErrorLogEntry> innerList = new List<ErrorLogEntry>(pageSize);
                    var count = log.GetErrors(pageIndex, pageSize, innerList);
                    list.AddRange(innerList);
                    if (list.Count >= initialCapacity)
                        break;
                }
                catch(Exception ex)
                {
                    System.Diagnostics.Debug.WriteLine(string.Format("{0}: {1}", log.GetType().Name, ex));
                }
            }

            foreach (var element in list.OrderByDescending(t => t.Error.Time).Take(pageSize))
                errorEntryList.Add(element);

            return errorEntryList.Count;
        }

        public override string Log(Error error)
        {
            var lastIndex = _errorLogs.Count - 1;
            for (int i = 0; i < _errorLogs.Count; i++)
            {
                var kvp = _errorLogs.ElementAt(i);
                if (i == lastIndex)
                    return kvp.Value.Log(error); // can throw an exception on the last chance errorlog instance.

                try
                {
                    return kvp.Value.Log(error);
                }
                catch (Exception ex)
                {
                    System.Diagnostics.Debug.WriteLine(string.Format("ErrorLog exception from {0} ({2}):\r\n{1}", kvp.Key, ex, kvp.Value.GetType().Name));
                }    
            }
            throw new Exception("there is a bug somewhere...");
        }
    }
}
